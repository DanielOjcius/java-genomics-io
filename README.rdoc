= Java Genomics IO API

This library provides a simple and performant API for working with many genomic file formats in a consistent fashion. The library requires JDK7 (http://www.oracle.com/technetwork/java/javase/downloads/index.html) since it makes use of switches on Strings and the new File/Path classes.

The library is mainly a wrapper to pull together multiple existing libraries, including Picard (http://picard.sourceforge.net) for reading SAM/BAM files and the BigWig/BigBed readers provided by the Broad Institute (http://code.google.com/p/bigwig). The complete list of file formats currently supported is: Bed, BigBed, BedGraph, GFF, GeneTrack, SAM, BAM, Wiggle, BigWig, Tabix. It seeks to accomplish two major tasks: 1) Allow many different formats to be accessed and manipulated in a consistent way without needing to worry about parsing implementation. For example, all line-based interval formats inherit from the Interval class so that tools can be agnostic to the specific format of input files. 2) Make random-access to information in large genomic datasets efficient by using indexing schemes. In this way, your tools can randomly pull information from specific genomic intervals without the major performance cost incurred by seeking through ASCII text files line-by-line. Line-based interval files are indexed as needed using a pure-Java reimplementation of  Tabix (http://samtools.sourceforge.net/tabix.shtml). Built-in indexes are used for BAM, BigWig, and BigBed files. ASCII Wiggle files are indexed using a custom implementation.

Complete JavaDocs are available at: http://palpant.us/java-genomics-io and may also be generated with the ant task "javadoc"

This library was prototyped in Ruby (https://github.com/timpalpant/bioruby-genomic-file).

== Compilation

An ant build script is provided for easy compilation. To see available ant tasks, call
  
  $ ant -p
  
To build the distribution as a jar file, call

  $ ant dist
  
To run the unit tests, call

  $ ant test
  
and to analyze the unit test code coverage, call

  $ ant coverage
  
Reports for the unit test results and code coverage are output in the reports subdirectory.

== Examples

For applications that only require interval information (chr:start-stop), the format of the interval file can be auto-detected, and the intervals can be iterated over:

  $ IntervalFile<? extends Interval> loci = null;
  $ try {
  $   loci = IntervalFile.autodetect(lociFile);
  $ } catch (IntervalFileSnifferException e) {
  $  log.fatal("Error autodetecting interval file format");
  $  e.printStackTrace();
  $ }
  $
  $ for (Interval interval : loci) {
  $   System.out.println(interval.toBed());
  $ }

This is particularly useful for writing Galaxy tools (http://getgalaxy.org).

Alternatively, if the file format is known and type-specific data is needed, it can be opened directly:

  $ BAMFile bam = new BAMFile(bamFile);
  $ for (BAMEntry entry : bam) {
  $   System.out.println(entry.getQuality());
  $ }
  $ 
  $ Iterator<BAMEntry> result = bam.query("chr1", 1, 1_000_000);
  $ while(result.hasNext()) {
  $   BAMEntry entry = result.next();
  $   // process the alignment
  $ }

This could also be accomplished by casting in the first place, but is not recommended.

Similar abstraction is provided for Wig/BigWig files:

  $ WigFile wig = WigFile.autodetect(wigOrBigWigFile);
  $ Iterator<WigItem> result = wig.query("chr23", 10_000, 1_000_000);
  $ while(result.hasNext()) {
  $   System.out.println(result.getWigValue());
  $ }
  $ 
  $ Iterator<WigItem> result2 = wig.query("chr23", 1, 10_000);
  $ float[] data = WigFile.flattenData(result2, 1, 10_000);
  $ float meanValueOnInterval = WigFile.mean(result2, 1, 10_000);

Rudimentary indexing is provided for text-Wig files, while BigWig files are accessed using the R-tree information. This means that performance is somewhat better for BigWig files. However, in some cases it is inconvenient or impossible to convert Wig files to BigWig since the wigToBigWig tool consumes ~4 x (file size) memory. The indexing scheme used for text-Wig files requires relatively modest memory, even for human-scale genomes, yet ensures an upper bound for seek times in random queries.

With all readers, data is buffered and lazy-parsed to minimize memory requirements and maximize disk performance.

See also https://github.com/timpalpant/java-genomics-toolkit for some full implementations using this library. A good starting point is: https://github.com/timpalpant/java-genomics-toolkit/blob/master/src/edu/unc/genomics/ngs/IntervalStats.java which demonstrates querying for data from Wig files based on a list of intervals in a Bed/BedGraph/GFF file.