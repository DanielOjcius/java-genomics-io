= Java Genomics IO API

This library provides a simple and performant API for working with many genomic file formats in a consistent fashion. It was prototyped in Ruby (https://github.com/timpalpant/bioruby-genomic-file). The library requires JDK7 (http://www.oracle.com/technetwork/java/javase/downloads/index.html) since it makes use of switches on Strings and the new File/Path classes.

The library is mainly a wrapper to pull together multiple existing libraries, including Picard (http://picard.sourceforge.net) for reading SAM/BAM files and the BigWig/BigBed readers provided by the Broad Institute (http://code.google.com/p/bigwig). The complete list of file formats currently supported is: Bed, BigBed, BedGraph, GFF, SAM, BAM, Wiggle, BigWig, Tabix, Fasta, Fastq.

Auto-indexing is implemented for randomly querying files by genomic region. Line-based interval files are indexed as needed with Tabix. Built-in indexes are used for BAM, BigWig, and BigBed files. ASCII Wiggle files are indexed using a custom implementation.

== Examples

For applications that only require interval information (chr:start-stop), the format of the interval file can be auto-detected, and the intervals can be iterated over:

  $ IntervalFile<? extends Interval> loci = null;
  $ try {
  $   loci = IntervalFile.autodetect(lociFile);
  $ } catch (IntervalFileSnifferException e) {
  $  log.fatal("Error autodetecting interval file format");
  $  e.printStackTrace();
  $ }
  $
  $ for (Interval interval : loci) {
  $   System.out.println(interval.toBed());
  $ }

This is particularly useful for writing Galaxy tools (http://getgalaxy.org).

Alternatively, if the file format is known and type-specific data is needed, it can be opened directly:

  $ BAMFile bam = new BAMFile(bamFile);
  $ for (BAMEntry entry : bam) {
  $   System.out.println(entry.getQuality());
  $ }
  $ 
  $ Iterator<BAMEntry> result = bam.query("chr1", 1, 1_000_000);
  $ while(result.hasNext()) {
  $   BAMEntry entry = result.next();
  $   // process the alignment
  $ }

This could also be accomplished by casting in the first place, but is not recommended.

Similar abstraction is provided for Wig/BigWig files:

  $ WigFile wig = WigFile.autodetect(wigOrBigWigFile);
  $ Iterator<WigItem> result = wig.query("chr23", 10_000, 1_000_000);
  $ while(result.hasNext()) {
  $   System.out.println(result.getWigValue());
  $ }
  $ 
  $ Iterator<WigItem> result2 = wig.query("chr23", 1, 10_000);
  $ float[] data = WigFile.flattenData(result2, 1, 10_000);

Rudimentary indexing is provided for text-Wig files, while BigWig files are accessed using the R-tree information. This means that performance is somewhat better for BigWig files. However, in some cases it is inconvenient or impossible to convert Wig files to BigWig since the wigToBigWig tool consumes ~4 x (file size) memory. The indexing scheme used for text-Wig files requires relatively modest memory, even for human-scale genomes, yet ensures an upper bound for seek times in random queries.

With all readers, data is buffered and lazy-parsed to minimize memory requirements and maximize disk performance.

See also https://github.com/timpalpant/java-genomics-toolkit for some full implementations using this library.